{"version":3,"sources":["animate.js"],"names":["define","langx","browser","noder","geom","styler","eventer","animates","animationName","animationDuration","animationTiming","animationEnd","normalizeCssEvent","cssReset","normalizeCssProperty","animate","elm","name","duration","ease","callback","delay","key","endEvent","wrappedCallback","cssValues","cssProperties","transforms","that","this","fired","hasScrollTop","isPlainObject","easing","complete","isString","speeds","undefined","normal","off","isFunction","eace","properties","v","supportedTransforms","test","top","right","bottom","left","css","size","width","height","push","dasherize","transitionEnd","transform","transitionProperty","join","transitionDuration","transitionDelay","transitionTiming","event","target","currentTarget","call","on","debounce","clientLeft","scrollToTop"],"mappings":"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","file":"../animate.js","sourcesContent":["define([\r\n    \"skylark-langx/langx\",\r\n    \"skylark-domx-browser\",\r\n    \"skylark-domx-noder\",\r\n    \"skylark-domx-geom\",\r\n    \"skylark-domx-styler\",\r\n    \"skylark-domx-eventer\",\r\n    \"./animates\"\r\n], function(langx, browser, noder, geom, styler, eventer,animates) {\r\n\r\n    var animationName,\r\n        animationDuration,\r\n        animationTiming,\r\n        animationDelay,\r\n\r\n        animationEnd = browser.normalizeCssEvent('AnimationEnd'),\r\n\r\n        cssReset = {};\r\n\r\n\r\n    cssReset[animationName = browser.normalizeCssProperty(\"animation-name\")] =\r\n        cssReset[animationDuration = browser.normalizeCssProperty(\"animation-duration\")] =\r\n        cssReset[animationDelay = browser.normalizeCssProperty(\"animation-delay\")] =\r\n        cssReset[animationTiming = browser.normalizeCssProperty(\"animation-timing-function\")] = \"\";\r\n\r\n    /*   \r\n     * Perform a custom animation of a set of CSS properties.\r\n     * @param {Object} elm  \r\n     * @param {Number or String} properties\r\n     * @param {String} ease\r\n     * @param {Number or String} duration\r\n     * @param {Function} callback\r\n     * @param {Number or String} delay\r\n     */\r\n    function animate(elm, name, duration, ease, callback, delay) {\r\n        var key,\r\n            cssValues = {},\r\n            cssProperties = [],\r\n            transforms = \"\",\r\n            that = this,\r\n            endEvent,\r\n            wrappedCallback,\r\n            fired = false,\r\n            hasScrollTop = false,\r\n            resetClipAuto = false;\r\n\r\n        if (langx.isPlainObject(duration)) {\r\n            ease = duration.easing;\r\n            callback = duration.complete;\r\n            delay = duration.delay;\r\n            duration = duration.duration;\r\n        }\r\n\r\n        if (langx.isString(duration)) {\r\n            duration = animates.speeds[duration];\r\n        }\r\n        if (duration === undefined) {\r\n            duration = animates.speeds.normal;\r\n        }\r\n        duration = duration / 1000;\r\n        if (animates.off) {\r\n            duration = 0;\r\n        }\r\n\r\n        if (langx.isFunction(ease)) {\r\n            callback = ease;\r\n            eace = \"swing\";\r\n        } else {\r\n            ease = ease || \"swing\";\r\n        }\r\n\r\n        if (delay) {\r\n            delay = delay / 1000;\r\n        } else {\r\n            delay = 0;\r\n        }\r\n\r\n        if (langx.isString(properties)) {\r\n            // keyframe animation\r\n            cssValues[animationName] = properties;\r\n            cssValues[animationDuration] = duration + \"s\";\r\n            cssValues[animationTiming] = ease;\r\n            endEvent = animationEnd;\r\n        } else {\r\n            // CSS transitions\r\n            for (key in properties) {\r\n                var v = properties[key];\r\n                if (supportedTransforms.test(key)) {\r\n                    transforms += key + \"(\" + v + \") \";\r\n                } else {\r\n                    if (key === \"scrollTop\") {\r\n                        hasScrollTop = true;\r\n                    }\r\n                    if (key == \"clip\" && langx.isPlainObject(v)) {\r\n                        cssValues[key] = \"rect(\" + v.top+\"px,\"+ v.right +\"px,\"+ v.bottom +\"px,\"+ v.left+\"px)\";\r\n                        if (styler.css(elm,\"clip\") == \"auto\") {\r\n                            var size = geom.size(elm);\r\n                            styler.css(elm,\"clip\",\"rect(\"+\"0px,\"+ size.width +\"px,\"+ size.height +\"px,\"+\"0px)\");  \r\n                            resetClipAuto = true;\r\n                        }\r\n\r\n                    } else {\r\n                        cssValues[key] = v;\r\n                    }\r\n                    cssProperties.push(langx.dasherize(key));\r\n                }\r\n            }\r\n            endEvent = transitionEnd;\r\n        }\r\n\r\n        if (transforms) {\r\n            cssValues[transform] = transforms;\r\n            cssProperties.push(transform);\r\n        }\r\n\r\n        if (duration > 0 && langx.isPlainObject(properties)) {\r\n            cssValues[transitionProperty] = cssProperties.join(\", \");\r\n            cssValues[transitionDuration] = duration + \"s\";\r\n            cssValues[transitionDelay] = delay + \"s\";\r\n            cssValues[transitionTiming] = ease;\r\n        }\r\n\r\n        wrappedCallback = function(event) {\r\n            fired = true;\r\n            if (event) {\r\n                if (event.target !== event.currentTarget) {\r\n                    return // makes sure the event didn't bubble from \"below\"\r\n                }\r\n                eventer.off(event.target, endEvent, wrappedCallback)\r\n            } else {\r\n                eventer.off(elm, animationEnd, wrappedCallback) // triggered by setTimeout\r\n            }\r\n            styler.css(elm, cssReset);\r\n            if (resetClipAuto) {\r\n //               styler.css(elm,\"clip\",\"auto\");\r\n            }\r\n            callback && callback.call(this);\r\n        };\r\n\r\n        if (duration > 0) {\r\n            eventer.on(elm, endEvent, wrappedCallback);\r\n            // transitionEnd is not always firing on older Android phones\r\n            // so make sure it gets fired\r\n            langx.debounce(function() {\r\n                if (fired) {\r\n                    return;\r\n                }\r\n                wrappedCallback.call(that);\r\n            }, ((duration + delay) * 1000) + 25)();\r\n        }\r\n\r\n        // trigger page reflow so new elements can animate\r\n        elm.clientLeft;\r\n\r\n        styler.css(elm, cssValues);\r\n\r\n        if (duration <= 0) {\r\n            langx.debounce(function() {\r\n                if (fired) {\r\n                    return;\r\n                }\r\n                wrappedCallback.call(that);\r\n            }, 0)();\r\n        }\r\n\r\n        if (hasScrollTop) {\r\n            scrollToTop(elm, properties[\"scrollTop\"], duration, callback);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    return animates.animate = animate;\r\n\r\n});"]}